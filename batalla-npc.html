<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Simulador de Batalla 3D — versión mejorada</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    canvas { display: block; }
    #hud { position: absolute; inset: 0; pointer-events: none; }
    .panel { pointer-events: auto; background: rgba(255,255,255,0.88); backdrop-filter: blur(4px); border-radius: 10px; padding: 12px 14px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); }
    #controls { position: absolute; top: 12px; left: 12px; display: grid; gap: 8px; min-width: 280px; }
    #stats { position: absolute; top: 12px; right: 12px; min-width: 240px; }
    #armySelection { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: min(92vw, 520px); }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: center; }
    .subgrid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
    label { font-size: 14px; display: flex; justify-content: space-between; gap: 8px; }
    input[type=number] { width: 74px; }
    input[type=range] { width: 100%; }
    button { padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background: #111; color: #fff; font-weight: 600; cursor: pointer; }
    button.secondary { background: #fff; color: #111; }
    .hidden { display: none; }
    .muted { color: #444; font-size: 12px; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="armySelection" class="panel">
      <h2 style="margin-top:0">Configuración de batalla</h2>
      <div class="row">
        <div>
          <h3>Equipo A</h3>
          <div class="subgrid">
            <label>Guerreros <input type="number" id="teamAWarriors" min="0" max="50" value="5"></label>
            <label>Arqueros <input type="number" id="teamAArchers" min="0" max="50" value="3"></label>
            <label>Magos <input type="number" id="teamAMages" min="0" max="50" value="2"></label>
          </div>
        </div>
        <div>
          <h3>Equipo B</h3>
          <div class="subgrid">
            <label>Guerreros <input type="number" id="teamBWarriors" min="0" max="50" value="5"></label>
            <label>Arqueros <input type="number" id="teamBArchers" min="0" max="50" value="3"></label>
            <label>Magos <input type="number" id="teamBMages" min="0" max="50" value="2"></label>
          </div>
        </div>
      </div>

      <div style="margin-top:8px" class="row">
        <label>Semilla procedural <input type="number" id="seedInput" min="0" max="999999" value="42"></label>
        <label>Velocidad sim. <input type="range" id="speedSlider" min="0.25" max="2" step="0.25" value="1"></label>
      </div>
      <p class="muted">Modo: <strong>Tiempo real</strong>. (Puedo añadir <em>por turnos</em> si lo necesita.)</p>
      <div style="display:flex; gap:8px; margin-top:10px;">
        <button id="startBattleBtn">Iniciar batalla</button>
        <button id="quickSkirmishBtn" class="secondary">Escaramuza rápida (5v5)</button>
      </div>
    </div>

    <div id="controls" class="panel hidden">
      <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
        <button id="pauseBtn">Pausar</button>
        <button id="resumeBtn" class="hidden">Reanudar</button>
        <button id="restartBtn" class="secondary">Reiniciar</button>
        <button id="resetCamBtn" class="secondary">Recentrar cámara</button>
        <label style="margin-left:8px; display:flex; align-items:center; gap:6px;">Velocidad <input type="range" id="runtimeSpeed" min="0.25" max="3" step="0.25" value="1"></label>
      </div>
      <div class="muted" style="margin-top:6px;">Terreno 100×100, obstáculos procedurales, IA con búsqueda de objetivo más cercano, línea de visión, enfriamientos y proyectiles.</div>
    </div>

    <div id="stats" class="panel hidden">
      <h3 style="margin:0 0 6px 0">Estadísticas</h3>
      <div id="teamAStatus">Equipo A: 0 vivos</div>
      <div id="teamBStatus">Equipo B: 0 vivos</div>
      <div id="battleStatus">Batalla en curso…</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // ========================
    // Configuración y constantes
    // ========================
    const config = {
      terrainSize: 100,
      obstacleDensity: 0.05,
      npcTypes: ['guerrero', 'arquero', 'mago'],
      attributes: {
        guerrero: { vida: 100, ataque: 20, velocidad: 3.0, defensa: 10, rango: 2.2, cadencia: 0.7 }, // unidades/seg
        arquero:  { vida:  80, ataque: 14, velocidad: 3.4, defensa:  5, rango: 9.0, cadencia: 1.2 },
        mago:     { vida:  60, ataque: 26, velocidad: 2.8, defensa:  0, rango: 7.0, cadencia: 1.6 }
      },
      projectile: {
        speed: 16, // unidades/seg
        radius: 0.18
      }
    };

    // ========================
    // Variables globales
    // ========================
    let scene, camera, renderer, controls, clock;
    let terrain, npcs = [], obstacles = [], projectiles = [];
    let ui = {}, paused = false, battleStartTime = 0, timeScale = 1, isRunning = false;
    let rngSeed = 42;

    // RNG determinista sencillo
    function mulberry32(a) {
      return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }
    let rand = mulberry32(rngSeed);

    // ========================
    // Inicialización
    // ========================
    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x8095a5, 0.015);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1200);
      camera.position.set(0, 62, 68);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.08;
      controls.target.set(0, 0, 0);

      clock = new THREE.Clock();

      // Luces básicas
      const amb = new THREE.AmbientLight(0xffffff, 0.55); scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 0.75); dir.position.set(40, 80, 30); scene.add(dir);

      // Helper de límites
      const grid = new THREE.GridHelper(config.terrainSize, 20, 0x333333, 0x999999);
      grid.position.y = 0.02; scene.add(grid);
      const box = new THREE.Box3Helper(new THREE.Box3(
        new THREE.Vector3(-config.terrainSize/2, 0, -config.terrainSize/2),
        new THREE.Vector3( config.terrainSize/2, 0,  config.terrainSize/2)
      ), 0x333333); scene.add(box);

      // UI refs
      ui.start = document.getElementById('startBattleBtn');
      ui.quick = document.getElementById('quickSkirmishBtn');
      ui.pause = document.getElementById('pauseBtn');
      ui.resume = document.getElementById('resumeBtn');
      ui.restart = document.getElementById('restartBtn');
      ui.resetCam = document.getElementById('resetCamBtn');
      ui.runtimeSpeed = document.getElementById('runtimeSpeed');
      ui.seed = document.getElementById('seedInput');
      ui.speedSlider = document.getElementById('speedSlider');
      ui.armySelection = document.getElementById('armySelection');
      ui.controls = document.getElementById('controls');
      ui.stats = document.getElementById('stats');
      ui.teamAStatus = document.getElementById('teamAStatus');
      ui.teamBStatus = document.getElementById('teamBStatus');
      ui.battleStatus = document.getElementById('battleStatus');

      // Eventos UI
      ui.start.addEventListener('click', () => startBattle(readComposition()));
      ui.quick.addEventListener('click', () => {
        document.getElementById('teamAWarriors').value = 5;
        document.getElementById('teamAArchers').value = 3;
        document.getElementById('teamAMages').value = 2;
        document.getElementById('teamBWarriors').value = 5;
        document.getElementById('teamBArchers').value = 3;
        document.getElementById('teamBMages').value = 2;
        startBattle(readComposition());
      });
      ui.pause.addEventListener('click', () => { paused = true; ui.pause.classList.add('hidden'); ui.resume.classList.remove('hidden'); });
      ui.resume.addEventListener('click', () => { paused = false; ui.resume.classList.add('hidden'); ui.pause.classList.remove('hidden'); });
      ui.restart.addEventListener('click', resetToMenu);
      ui.resetCam.addEventListener('click', () => { camera.position.set(0, 62, 68); controls.target.set(0,0,0); });
      ui.runtimeSpeed.addEventListener('input', e => timeScale = parseFloat(e.target.value));
      ui.speedSlider.addEventListener('input', e => timeScale = parseFloat(e.target.value));
      ui.seed.addEventListener('change', e => { rngSeed = parseInt(e.target.value||'42', 10); rand = mulberry32(rngSeed); });

      window.addEventListener('resize', onResize);

      // Mostrar menú de ejércitos
      showMenu();

      // Render loop único
      animate();
    }

    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function showMenu(){
      ui.armySelection.classList.remove('hidden');
      ui.controls.classList.add('hidden');
      ui.stats.classList.add('hidden');
      isRunning = false; paused = false;
      ui.pause.classList.remove('hidden'); ui.resume.classList.add('hidden');
      // Limpiar escena salvo helpers y luces
      clearBattleEntities();
    }

    function readComposition(){
      return {
        A: {
          guerrero: parseInt(document.getElementById('teamAWarriors').value||'0',10),
          arquero:  parseInt(document.getElementById('teamAArchers').value||'0',10),
          mago:     parseInt(document.getElementById('teamAMages').value||'0',10)
        },
        B: {
          guerrero: parseInt(document.getElementById('teamBWarriors').value||'0',10),
          arquero:  parseInt(document.getElementById('teamBArchers').value||'0',10),
          mago:     parseInt(document.getElementById('teamBMages').value||'0',10)
        }
      };
    }

    function validateComp(comp){
      const totalA = comp.A.guerrero + comp.A.arquero + comp.A.mago;
      const totalB = comp.B.guerrero + comp.B.arquero + comp.B.mago;
      return totalA >= 1 && totalB >= 1;
    }

    function startBattle(composition){
      if(!validateComp(composition)) { alert('Cada equipo debe tener al menos un NPC.'); return; }
      clearBattleEntities(true);
      rngSeed = parseInt(ui.seed.value||'42', 10); rand = mulberry32(rngSeed);

      ui.armySelection.classList.add('hidden');
      ui.controls.classList.remove('hidden');
      ui.stats.classList.remove('hidden');

      generateTerrain();
      generateObstacles();
      generateNPCs(composition);

      battleStartTime = performance.now();
      paused = false; isRunning = true; ui.battleStatus.textContent = 'Batalla en curso…';
    }

    // ========================
    // Generación procedural
    // ========================
    function generateTerrain(){
      if(terrain) { scene.remove(terrain); disposeMesh(terrain); terrain = null; }
      const geom = new THREE.PlaneGeometry(config.terrainSize, config.terrainSize, 64, 64);
      // Elevación simple (value noise / hash noise suavizado)
      const pos = geom.attributes.position;
      for(let i=0; i<pos.count; i++){
        const x = pos.getX(i) * 0.08; // escala
        const y = pos.getY(i) * 0.08;
        const h = fbmNoise(x, y) * 4.0; // altura máx ±4
        pos.setZ(i, h);
      }
      pos.needsUpdate = true;
      geom.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({ color: 0x6fae6f, roughness: 1.0, metalness: 0.0, flatShading: false });
      terrain = new THREE.Mesh(geom, mat);
      terrain.rotation.x = -Math.PI/2;
      terrain.receiveShadow = false;
      scene.add(terrain);
    }

    // Fractal Brownian Motion sobre un hash noise determinista
    function baseNoise(x, y){
      // Hash 2D determinista con semilla
      const n = Math.sin((x*127.1 + y*311.7 + rngSeed) * 43758.5453);
      return (n - Math.floor(n)); // [0,1)
    }
    function smoothNoise(x, y){
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const xf = x - x0, yf = y - y0;
      function lerp(a,b,t){ return a + (b-a)*t; }
      const n00 = baseNoise(x0,   y0);
      const n10 = baseNoise(x0+1, y0);
      const n01 = baseNoise(x0,   y0+1);
      const n11 = baseNoise(x0+1, y0+1);
      const nx0 = lerp(n00, n10, xf);
      const nx1 = lerp(n01, n11, xf);
      return lerp(nx0, nx1, yf) * 2 - 1; // [-1,1]
    }
    function fbmNoise(x, y){
      let f = 0, amp = 1, freq = 1;
      for(let o=0; o<4; o++){ f += amp * smoothNoise(x*freq, y*freq); amp *= 0.5; freq *= 2.0; }
      return f;
    }

    function generateObstacles(){
      const count = Math.floor(config.terrainSize * config.terrainSize * config.obstacleDensity);
      for(let i=0; i<count; i++){
        const isTree = rand() > 0.5;
        let geom, mat, h;
        if(isTree){
          geom = new THREE.CylinderGeometry(0.4, 0.6, 4.8, 8);
          mat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B, roughness: 1 });
          h = 2.4;
        } else {
          geom = new THREE.DodecahedronGeometry(1.2);
          mat = new THREE.MeshStandardMaterial({ color: 0x7a7a7a, roughness: 1 });
          h = 1.2;
        }
        const m = new THREE.Mesh(geom, mat);
        const px = (rand()-0.5) * config.terrainSize;
        const pz = (rand()-0.5) * config.terrainSize;
        const py = 0.0 + h; // centrado aproximado
        m.position.set(px, py, pz);
        m.userData.radius = isTree ? 1.0 : 1.2; // para colisiones simples
        scene.add(m); obstacles.push(m);
      }
    }

    function generateNPCs(comp){
      npcs = []; projectiles = [];
      const teams = ['A','B'];
      const colors = { A: 0xff4d4d, B: 0x4d7dff };
      const sideX = { A: -config.terrainSize/3, B: config.terrainSize/3 };
      teams.forEach(team => {
        const conf = comp[team];
        for(const type of config.npcTypes){
          const n = conf[type]|0;
          for(let i=0;i<n;i++){
            const npc = createNPC(team, type, colors[team]);
            const row = Math.floor(i/5), col = i%5;
            npc.mesh.position.set(
              sideX[team] + (rand()-0.5)*6,
              1.1,
              (row*2.0 - 8) + col*1.6 + (rand()-0.5)*1.5
            );
            scene.add(npc.mesh);
            npcs.push(npc);
          }
        }
      });
    }

    function createNPC(team, type, color){
      const group = new THREE.Group();
      const body = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshStandardMaterial({ color, roughness: 0.8 }));
      group.add(body);

      // barra de vida (billboard sencillo)
      const barBg = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.22, 0.22), new THREE.MeshBasicMaterial({ color: 0x222222 }));
      const bar = new THREE.Mesh(new THREE.BoxGeometry(1.98, 0.2, 0.2), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
      const barGroup = new THREE.Group();
      barGroup.add(barBg); barGroup.add(bar); barGroup.position.set(0, 1.6, 0);
      bar.position.x = -0.99 + 0.99; // centrado inicial
      group.add(barGroup);

      const base = config.attributes[type];
      const stats = { vida: base.vida, vidaMax: base.vida, ataque: base.ataque, velocidad: base.velocidad, defensa: base.defensa, rango: base.rango, cadencia: base.cadencia };

      return {
        team, type, attributes: stats,
        mesh: group,
        healthBar: bar,
        healthBarGroup: barGroup,
        target: null,
        status: 'vivo',
        cooldown: 0
      };
    }

    // ========================
    // Bucle principal
    // ========================
    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta() * timeScale, 0.05); // tope por estabilidad
      controls.update();

      if(isRunning && !paused){
        updateNPCs(dt);
        updateProjectiles(dt);
        checkBattleStatus();
      }

      // billboards de vida miran a cámara
      for(const n of npcs){ if(n.healthBarGroup) n.healthBarGroup.lookAt(camera.position); }

      renderer.render(scene, camera);
    }

    function updateNPCs(dt){
      for(const npc of npcs){
        if(npc.status !== 'vivo') continue;
        if(!npc.target || npc.target.status !== 'vivo') npc.target = findNearestEnemy(npc);
        if(!npc.target) continue;

        const dist = npc.mesh.position.distanceTo(npc.target.mesh.position);
        const inRange = dist <= npc.attributes.rango;
        if(!inRange){
          moveTowards(npc, npc.target, dt);
        } else {
          tryAttack(npc, npc.target);
        }
        updateHealthBar(npc);
      }
    }

    function moveTowards(npc, target, dt){
      const dir = new THREE.Vector3().subVectors(target.mesh.position, npc.mesh.position).normalize();
      const step = npc.attributes.velocidad * dt;
      npc.mesh.position.addScaledVector(dir, step);

      // evitar obstáculos aproximando círculos
      for(const obs of obstacles){
        const d = npc.mesh.position.distanceTo(obs.position);
        const minD = 1.6 + (obs.userData.radius||1.0);
        if(d < minD){
          const avoid = new THREE.Vector3().subVectors(npc.mesh.position, obs.position).normalize();
          npc.mesh.position.addScaledVector(avoid, (minD - d) * 0.6);
        }
      }

      // límites
      npc.mesh.position.clamp(
        new THREE.Vector3(-config.terrainSize/2, 1.1, -config.terrainSize/2),
        new THREE.Vector3( config.terrainSize/2, 1.1,  config.terrainSize/2)
      );
    }

    function lineOfSight(a, b){
      // Chequeo simple: si un obstáculo está muy cerca del segmento AB, se considera bloqueado
      const A = a.mesh.position, B = b.mesh.position;
      const AB = new THREE.Vector3().subVectors(B, A);
      const ab2 = AB.lengthSq();
      for(const o of obstacles){
        const AO = new THREE.Vector3().subVectors(o.position, A);
        const t = THREE.MathUtils.clamp(AO.dot(AB)/ab2, 0, 1);
        const P = new THREE.Vector3().copy(AB).multiplyScalar(t).add(A);
        const d = P.distanceTo(o.position);
        if(d < (o.userData.radius||1.0) + 0.6) return false;
      }
      return true;
    }

    function tryAttack(npc, target){
      if(npc.cooldown > 0) { npc.cooldown -= clock.getDelta() * timeScale; return; }
      // chequeo de línea de visión para distancia > melee
      const ranged = npc.attributes.rango > 3.0;
      if(ranged && !lineOfSight(npc, target)) return;

      if(npc.type === 'guerrero'){
        // daño directo
        dealDamage(npc, target, npc.attributes.ataque);
      } else {
        // proyectil
        spawnProjectile(npc, target);
      }
      npc.cooldown = npc.attributes.cadencia;
    }

    function dealDamage(attacker, target, raw){
      const dmg = Math.max(0, raw - (target.attributes.defensa||0));
      target.attributes.vida -= dmg;
      if(target.attributes.vida <= 0){ target.status = 'muerto'; scene.remove(target.mesh); }
    }

    function spawnProjectile(npc, target){
      const geom = new THREE.SphereGeometry(config.projectile.radius, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ color: npc.type === 'mago' ? 0xaa88ff : 0x222222 });
      const m = new THREE.Mesh(geom, mat);
      m.position.copy(npc.mesh.position).add(new THREE.Vector3(0, 0.2, 0));
      const dir = new THREE.Vector3().subVectors(target.mesh.position, npc.mesh.position).normalize();
      projectiles.push({ mesh: m, team: npc.team, damage: npc.attributes.ataque, vel: dir.multiplyScalar(config.projectile.speed), ttl: 2.5, target });
      scene.add(m);
    }

    function updateProjectiles(dt){
      for(let i=projectiles.length-1; i>=0; i--){
        const p = projectiles[i];
        p.mesh.position.addScaledVector(p.vel, dt);
        p.ttl -= dt;
        // impacta si llega cerca del target vivo
        if(p.target && p.target.status==='vivo'){
          if(p.mesh.position.distanceTo(p.target.mesh.position) < 1.1){
            dealDamage({team:p.team}, p.target, p.damage);
            scene.remove(p.mesh); disposeMesh(p.mesh); projectiles.splice(i,1); continue;
          }
        }
        if(p.ttl <= 0){ scene.remove(p.mesh); disposeMesh(p.mesh); projectiles.splice(i,1); }
      }
    }

    function updateHealthBar(npc){
      const r = Math.max(0, npc.attributes.vida / npc.attributes.vidaMax);
      npc.healthBar.scale.x = Math.max(0.001, r);
      npc.healthBar.position.x = -0.99 + 0.99*r;
      // verde -> rojo aproximado via HSL
      const h = 0.33 * r; // 0.33 ≈ 120°
      npc.healthBar.material.color.setHSL(h, 1, 0.5);
    }

    function findNearestEnemy(npc){
      let nearest = null, minD = Infinity;
      for(const e of npcs){
        if(e.team === npc.team || e.status !== 'vivo') continue;
        const d = npc.mesh.position.distanceTo(e.mesh.position);
        if(d < minD){ minD = d; nearest = e; }
      }
      return nearest;
    }

    function checkBattleStatus(){
      const aAlive = npcs.filter(n => n.team==='A' && n.status==='vivo').length;
      const bAlive = npcs.filter(n => n.team==='B' && n.status==='vivo').length;
      ui.teamAStatus.textContent = `Equipo A: ${aAlive} vivos`;
      ui.teamBStatus.textContent = `Equipo B: ${bAlive} vivos`;
      if(aAlive===0 || bAlive===0){
        const winner = aAlive>0 ? 'Equipo A' : 'Equipo B';
        const duration = ((performance.now() - battleStartTime)/1000).toFixed(2);
        ui.battleStatus.textContent = `Ganador: ${winner}. Duración: ${duration}s`;
        paused = true; isRunning = false;
      }
    }

    // ========================
    // Limpieza y utilidades
    // ========================
    function clearBattleEntities(removeEverything){
      // Quita NPCs, proyectiles, terreno y obstáculos
      for(const n of npcs){ scene.remove(n.mesh); disposeMesh(n.mesh); }
      for(const p of projectiles){ scene.remove(p.mesh); disposeMesh(p.mesh); }
      npcs.length = 0; projectiles.length = 0;
      for(const o of obstacles){ scene.remove(o); disposeMesh(o); }
      obstacles.length = 0;
      if(terrain){ scene.remove(terrain); disposeMesh(terrain); terrain = null; }

      // Si se pide completo, mantener luces y helpers, borrar resto
      if(removeEverything){
        const keep = new Set();
        scene.traverse(obj => { if(obj.type.includes('Light') || obj instanceof THREE.GridHelper || obj instanceof THREE.Box3Helper) keep.add(obj); });
        const toRemove = [];
        scene.children.forEach(ch => { if(!keep.has(ch)) toRemove.push(ch); });
        for(const ch of toRemove){ scene.remove(ch); disposeMesh(ch); }
      }
    }

    function disposeMesh(obj){
      if(!obj) return;
      obj.traverse?.(child => {
        if(child.geometry){ child.geometry.dispose?.(); }
        if(child.material){
          if(Array.isArray(child.material)) child.material.forEach(m => m.dispose?.());
          else child.material.dispose?.();
        }
      });
    }

    function resetToMenu(){ showMenu(); }

    // ========================
    // Arranque
    // ========================
    init();
  </script>
</body>
</html>
